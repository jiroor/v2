# CLAUDE.md

このファイルは、Claude Codeがプロジェクトのコンテキストを理解するための設定ファイルです。

---

## 🚨 最重要ルール（必ず守ること）

### 1. 会話言語
**すべての会話は日本語で行うこと**
- Claudeからユーザーへの応答は**必ず日本語**
- コード内のコメントやドキュメントも日本語で記述
- コミットメッセージ：
  - 概要部分（1行目）: 英語
  - 詳細部分: 日本語可
- 例外なく日本語で会話を行うこと

### 2. コミット漏れ防止
- 実装完了 = コード変更 + 動作確認 + **コミット**
- ユーザーへの完了報告前に必ずコミットを実行
- `git status`で working tree clean を確認してから報告

### 3. ドキュメント優先
- 仕様の追加・変更時は、必ずドキュメントを先に更新してから実装
- 設計判断は`memories/thinking/`に記録
- 新機能は`memories/features/`に記録

---

## 重要な設定

## プロジェクト概要

**プロジェクト名**: ユーティリティツール集

**説明**: 軽量でミニマルなデザインのReactベースユーティリティツールサイト。タイマー、テキストツール、QRコード生成などの日常的に使える便利なツールを提供します。

## 技術スタック

- **フレームワーク**: Vite + React 18
- **言語**: TypeScript
- **ルーティング**: React Router v6
- **スタイリング**: CSS Modules
- **デプロイ**: Vercel

## プロジェクト構造

```
/
├── docs/              # 設計ドキュメント
├── memories/          # 開発ログ・記録
│   ├── thinking/      # 設計判断・思考過程
│   ├── features/      # 機能追加・改修記録
│   └── deleted/       # 削除・廃止記録
├── public/            # 静的アセット
└── src/
    ├── components/    # 共通コンポーネント
    ├── pages/         # ページコンポーネント
    ├── hooks/         # カスタムフック
    ├── utils/         # ユーティリティ関数
    ├── types/         # 型定義
    └── constants/     # 定数定義
```

## 提供するツール

### タイマー系
- カウントダウンタイマー
- ストップウォッチ
- ポモドーロタイマー

### テキストツール
- 文字数カウンター
- テキスト差分表示
- ランダム文字列生成

### その他ツール
- QRコード生成
- パスワード生成
- カラーピッカー

## 設計原則

1. **軽量性**: バンドルサイズ < 100KB (gzip圧縮後)
2. **シンプルさ**: 必要最小限の機能とUI
3. **ミニマルデザイン**: 白黒ベース、装飾を排除
4. **完全クライアントサイド**: バックエンド不要

## 開発ガイドライン

### コーディング規約

- **コンポーネント**: 関数コンポーネント + Hooks
- **型定義**: すべての props, state に型を定義
- **CSS**: CSS Modules を使用し、グローバルスタイルを最小限に
  - **!important 禁止**: CSSで `!important` は絶対に使用しない
  - **インラインスタイル禁止**: JSXの `style` 属性は使用しない
  - **shadcn/uiのカスタマイズ**: Tailwindクラスを`className` propに直接追加する（公式推奨）
    ```tsx
    // ✅ 良い例：Tailwindクラスを直接追加
    <Input className="w-[60px] h-10" />
    <Button className="h-10">ボタン</Button>

    // ❌ 悪い例：CSS Modulesで詳細度を上げる
    <Input className={styles.input} />
    /* CSS: input.input[type="text"] { height: 40px; } */
    ```
  - **理由**: shadcn/uiは`cn()`関数とtailwind-mergeでクラス競合を自動解決するため、詳細度の問題が発生しない
- **命名規則**:
  - コンポーネント: PascalCase
  - 関数/変数: camelCase
  - 定数: UPPER_SNAKE_CASE
  - CSS クラス: kebab-case

### ファイル構成

- コンポーネントファイルと同名の CSS Modules を配置
- 1コンポーネント = 1ファイル
- ページコンポーネントは pages/ 配下にカテゴリ分け

### 状態管理

- ローカル状態: `useState`
- 永続化: LocalStorage + カスタムフック
- グローバル状態: 不要（小規模のため）

### パフォーマンス

- 遅延ローディング: `React.lazy()` でページコンポーネントを分割
- メモ化: `useMemo`, `useCallback`, `memo` を適切に使用
- 外部ライブラリ: 最小限に抑える

## 重要なドキュメント

- [プロジェクト概要](./docs/README.md)
- [アーキテクチャ設計](./docs/architecture.md)
- [デザインシステム](./docs/design-system.md)

## 依存関係

### 本番依存
- react: ^18.2.0
- react-dom: ^18.2.0
- react-router-dom: ^6.20.0
- qrcode: ^1.5.3

### 開発依存
- @vitejs/plugin-react: ^4.2.0
- typescript: ^5.3.0
- vite: ^5.0.0

## デプロイ

- **プラットフォーム**: Vercel
- **ビルドコマンド**: `npm run build`
- **出力ディレクトリ**: `dist`
- **自動デプロイ**: main ブランチへの push 時

## 開発コマンド

```bash
npm run dev         # 開発サーバー起動
npm run build       # プロダクションビルド
npm run preview     # ビルド結果プレビュー
npm run type-check  # 型チェック
```

## 現在の開発状況

### Phase 1: 基盤構築
- [x] プロジェクト設計
- [ ] Vite + React セットアップ
- [ ] ルーティング設定
- [ ] 基本レイアウト作成

### Phase 2: コアツール実装
- [ ] カウントダウンタイマー
- [ ] ストップウォッチ
- [ ] 文字数カウンター

### Phase 3: 追加ツール
- [ ] ポモドーロタイマー
- [ ] テキスト差分
- [ ] ランダム文字列生成
- [ ] QRコード生成
- [ ] パスワード生成
- [ ] カラーピッカー

### Phase 4: 最適化
- [ ] パフォーマンス最適化
- [ ] PWA対応検討
- [ ] テスト追加

## 開発ログルール

このプロジェクトでは、設計判断や機能追加の背景を記録することで、Claudeが過去の意思決定を理解し、一貫性のある開発を継続できるようにします。

### ディレクトリ構成と目的

| ディレクトリ | 目的 | 記録内容 |
|------------|------|---------|
| `memories/thinking/` | 設計判断や思考過程を外部化 | 迷った点、却下した案、判断理由などを短文で残す。Claudeが設計意図を理解できる形に |
| `memories/features/` | 新機能の追加・改修の目的と背景を記録 | 実装目的、画面構成、データ構造、リスク、完了条件などを簡潔にまとめる |
| `memories/deleted/` | 削除・廃止した機能やファイルの履歴を残す | 削除理由、影響範囲、代替手段、再発防止策を記録する |

### 記録タイミング

#### memories/thinking/ に記録するケース
- 複数の実装方法で迷ったとき
- 技術選定で判断が必要だったとき
- パフォーマンスとシンプルさのトレードオフが発生したとき
- アーキテクチャ上の重要な決定をしたとき

**ファイル名**: `YYYYMMDD-short-description.md`

**テンプレート**:
```markdown
# [判断内容の要約]

## 日付
YYYY-MM-DD

## 状況
[どんな問題・課題に直面したか]

## 検討した選択肢
1. [選択肢A]: メリット / デメリット
2. [選択肢B]: メリット / デメリット
3. [選択肢C]: メリット / デメリット

## 決定
[どの選択肢を選んだか]

## 理由
[なぜその選択をしたか]

## 懸念点
[将来見直す可能性があるか]
```

#### memories/features/ に記録するケース
- 新機能を追加するとき
- 既存機能を大きく改修するとき
- APIやデータ構造を変更するとき

**ファイル名**: `YYYYMMDD-feature-name.md`

**テンプレート**:
```markdown
# [機能名]

## 日付
YYYY-MM-DD

## 実装目的
[なぜこの機能が必要か]

## 画面構成・UI
[どんな画面・UIか]

## データ構造
[使用するstate、propsなど]

## 実装ファイル
- src/...
- src/...

## リスク・注意点
[パフォーマンス、バンドルサイズなどの懸念]

## 完了条件
- [ ] 項目1
- [ ] 項目2
```

#### memories/deleted/ に記録するケース
- ファイルを削除したとき
- 機能を廃止したとき
- コンポーネントをリファクタリングで統合・削除したとき

**ファイル名**: `YYYYMMDD-deleted-item-name.md`

**テンプレート**:
```markdown
# [削除したもの]

## 日付
YYYY-MM-DD

## 削除内容
[何を削除したか]

## 削除理由
[なぜ削除したか]

## 影響範囲
[どのファイル・機能に影響があったか]

## 代替手段
[削除後、どう対応するか]

## 再発防止策
[同じ問題を起こさないために]
```

### 記録の原則

1. **簡潔に**: 1ファイル = 1トピック
2. **検索可能に**: ファイル名に日付と内容を含める
3. **結論ファースト**: 判断結果を先に書く
4. **未来の自分へ**: なぜその判断をしたかを明確に

### Claudeへの指示

- 重要な設計判断をした際は、必ず `memories/thinking/` にログを残すこと
- 新機能実装開始時は、`memories/features/` に記録を作成すること
- ファイルや機能を削除する際は、`memories/deleted/` に理由を記録すること
- 過去のログを参照して、一貫性のある判断を行うこと
- **仕様の追加・変更時は、必ずドキュメントを先に更新してから実装に進むこと**

## 開発フロー

### 機能追加・変更の手順

1. **ドキュメント更新**（必須）
   - `memories/features/` の該当ファイルを更新
   - 必要に応じて `memories/thinking/` に設計判断を記録
   - `docs/` の関連ドキュメントを更新

2. **実装**
   - ドキュメントに基づいてコードを実装
   - 型定義、コンポーネント、スタイルなどを追加・変更

3. **動作確認**
   - ブラウザで機能をテスト
   - すべての要件が満たされていることを確認

4. **コミット**
   - 変更内容を明確なメッセージでコミット

### 機能実装の基本フロー

1. **機能記録の作成**: `memories/features/` に実装内容を記録
2. **実装**: コンポーネント、フック、スタイルを作成
3. **動作確認**: 開発サーバーで動作確認（可能であればchrome-devtools-mcpを使用）
4. **コミット**: 次のステップに進む前に必ずコミット

### コミットタイミング

- **必須**: 機能実装が完了し、次のステップに進む前
- **必須**: 複数の機能を実装する際は、各機能ごとにコミット
- **必須**: ユーザーからの要求に対する実装が完了したとき
- **推奨**: 設計判断を記録した後
- **推奨**: 大きな変更を行った後

### コミット漏れ防止

コミット漏れを防ぐため、以下を徹底すること：

1. **実装完了の定義を明確に**
   - 実装完了 = コード変更 + 動作確認 + **コミット**
   - コミットが完了するまでは「実装完了」とは言えない

2. **タスク完了時のチェックリスト**
   - [ ] コードの変更が完了している
   - [ ] ドキュメントが更新されている（必要な場合）
   - [ ] 動作確認が完了している
   - [ ] `git status` で変更があることを確認
   - [ ] `git add` と `git commit` でコミットを作成
   - [ ] `git status` で working tree clean を確認

3. **会話の区切りでのコミット確認**
   - ユーザーからの要求に対する作業が完了したら、必ずコミット
   - 「完了しました」と報告する前に、コミットを確認
   - 次のタスクに移る前に、現在の変更をコミット

### コミットメッセージ規約

```
[動詞] [概要]

- [詳細1]
- [詳細2]
- [詳細3]

[追加情報]

🤖 Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
```

例:
- `Implement countdown timer feature`
- `Add stopwatch component`
- `Update design system colors`

## Tailwind CSS v4 使用時の重要ルール

**絶対に守ること**：
- **CSS Modulesや他のCSSファイルで`* { padding: 0; }`や`* { margin: 0; }`などのグローバルリセットを記述しない**
- Tailwind CSS v4のPreflightが既に`@layer base`内でリセットを提供している
- グローバルリセットを`@layer`の外に記述すると、CSS cascade layersの仕組みにより、Tailwind utilityクラスより優先度が高くなり、padding/marginが効かなくなる
- `!important`を使うのは一時的な回避策であり、根本的な解決ではない
- 問題が発生した場合は、まず`@layer`の外にあるグローバルスタイル（特に`* { }`セレクタ）を疑うこと

**技術的背景**：
- Tailwind CSS v4はCSS cascade layersを使用
- レイヤーの優先順位: unlayered（最高） > `@layer utilities` > `@layer components` > `@layer base`
- `@layer`の外にあるスタイルは"unlayered"として扱われ、すべてのlayered stylesより優先される

## 注意事項

- 計算機系ツールは本プロジェクトのスコープ外
- すべてのツールはクライアントサイドのみで動作
- 外部APIへの依存は避ける
- バンドルサイズを常に意識する
- **重要**: 設計判断、機能追加、削除時は必ずmemoriesに記録すること
- **重要**: 次のステップに進む前に必ずコミットすること

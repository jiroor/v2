# PWA実装の戦略選定

## 日付
2025-11-06

## 状況
スマホでアプリケーション全体を使いやすくするため、PWA対応を実装する必要がある。
Service Workerの実装方法と更新戦略を決定する必要があった。

## 検討した選択肢

### 1. Service Workerの実装方法

#### 選択肢A: 手動でService Workerを実装
- メリット: 完全なコントロール、軽量
- デメリット: 実装コストが高い、メンテナンスが大変、バグのリスク

#### 選択肢B: vite-plugin-pwaを使用
- メリット: Viteとの統合が容易、Workbox統合、自動生成、開発時HMRと共存
- デメリット: 若干のバンドルサイズ増加（~50KB）

### 2. 更新戦略

#### 選択肢A: autoUpdate（自動更新）
- メリット: ユーザーが意識せず更新される
- デメリット: ユーザーの操作中に突然変わる可能性

#### 選択肢B: prompt（通知して更新）
- メリット: ユーザーが更新タイミングを制御できる、UXが良い
- デメリット: 更新通知UIの実装が必要

### 3. キャッシュ戦略

#### 選択肢A: NetworkFirst（ネットワーク優先）
- メリット: 常に最新のコンテンツを表示
- デメリット: オフライン時の体験が悪い

#### 選択肢B: CacheFirst（キャッシュ優先）
- メリット: 高速、完全オフライン対応
- デメリット: 更新が遅れる可能性

#### 選択肢C: StaleWhileRevalidate（キャッシュを返しつつバックグラウンド更新）
- メリット: 高速かつ常に更新、良いバランス
- デメリット: 若干複雑

## 決定

1. **vite-plugin-pwaを使用**
2. **更新戦略: prompt（通知方式）**
3. **キャッシュ戦略: StaleWhileRevalidate**

## 理由

### vite-plugin-pwaを選んだ理由
- プロジェクトの設計原則「軽量性」と「シンプルさ」を維持しつつ、PWAの複雑な実装を避けられる
- Workbox統合により、実績のあるキャッシュ戦略を利用できる
- Viteとの統合が容易で、開発体験を損なわない
- バンドルサイズ増加は50KB程度で、目標の100KB以内に収まる

### prompt方式を選んだ理由
- ユーザーが作業中（タイマー実行中など）に突然更新されると困る
- 「更新があります」という通知により、透明性が高い
- ユーザーが更新タイミングを選べるのでUXが良い

### StaleWhileRevalidateを選んだ理由
- 完全クライアントサイドアプリのため、即座の表示が重要
- バックグラウンドで更新するので、次回アクセス時には最新版になる
- オフライン対応と最新性のバランスが最適

## 懸念点

1. **バンドルサイズ**: Service Workerの追加で約50KB増加
   - 対策: gzip圧縮後でも100KB以内に収める
   - モニタリング: ビルド時にサイズをチェック

2. **開発時のキャッシュ問題**: 開発中にキャッシュが邪魔になる可能性
   - 対策: 開発モードではService Workerを無効化

3. **iOS Safariの制限**: PWAの機能に一部制限がある
   - 対策: 基本機能（オフライン、ホーム画面追加）に限定

## 実装方針

- manifest.json: アプリ名「Rakit」、テーマカラー黒、standalone表示
- アイコン: 192x192、512x512、apple-touch-icon 180x180
- 更新通知: シンプルなトースト通知UI
- キャッシュ対象: HTML、CSS、JS、画像
- キャッシュ除外: 外部API（存在しないが念のため）

## 将来の見直し可能性

- ユーザーフィードバックにより、autoUpdate方式に変更する可能性
- オフライン対応の範囲を拡大する可能性
- プッシュ通知の追加（現時点ではスコープ外）
